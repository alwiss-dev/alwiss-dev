Hi, Iâ€™m Mert.

Software I create serves practical purposes. What matters most? Systems stay stable even when stretched. Clarity sticks around, even during high stress. Performance holds up, despite shifting needs. Not interested in fads - watching behavior comes first. Once deployed, how do servers handle heavy traffic? How does code age across months of use? User actions reveal patterns no design document predicts.

A steady system beats a flashy one every time. Building things that grow smoothly comes first, so I focus on designs ready for heavier loads without breaking down later. Real-world testing shapes better outcomes compared to theories never challenged outside documents. What survives busy hours online proves its worth far beyond initial sketches.

---

Technical Skills and Experience

Programming Languages

C# / .NET
Behind most server-side parts in .NET, C# stands as the main tool. Whether it is an API or a service running quietly in the background, tasks continue without needing someone to trigger them. Events tend to set things in motion - responses follow when signals arrive, not because of immediate demands. Smooth links to other components make sure everything fits together without friction.

JavaScript (Node.js)
Because Node.js handles live data efficiently, it powers applications needing immediate feedback. Tools built on this runtime often manage chats or alerts without delay. Sometimes a minimal service benefits simply from its speed. Live interactions tend to run smoothly when structured around non-blocking operations.

TypeScript
With TypeScript, bigger JavaScript projects gain clarity through added constraints. Errors often show up early - during compilation - not later when the app runs. This shift means fewer surprises down the line. As code expands, keeping it manageable becomes less of a burden. The tool fits well where systems evolve steadily over months or years.

Python
Scripting tasks take up most of its role, often handling repetitive processes behind the scenes. While built mainly for automation, it quietly strengthens how internal systems communicate. Behind operational routines, this tool runs unseen yet stays essential. Instead of front-facing functions, it focuses on keeping backend operations steady and reliable.

Rust
Where speed and tight resource handling matter most, Rust becomes a natural fit. For tasks like running background jobs or building low-level utilities, it delivers steady results without extra cost. Predictable behavior under pressure makes it suitable in environments demanding efficiency. System tools often rely on its precision when every cycle counts.

---

Backend and Architecture

Building backend setups comes naturally - from tidy monolithic designs to split-up structures ready for microservices. Each time, the aim stays sharp: clear flow, room to grow, steady handling.

RESTful APIs with WebSocket Real-Time Communication
- Authentication systems using JWT, refresh tokens, and session handling
Security begins with design choices that limit exposure. Access depends on assigned roles, shaping who can do what. Requests get restricted over time to prevent overload. Each layer adds protection by narrowing possibilities
Using Redis with cache first approaches
- Event-driven and message-based system design

---

Frontend

- React / React.js for modern, component-based user interfaces
- API-driven state management
- Frontend architecture designed with performance and maintainability in mind

---

Databases and Caching

- Redis for caching, pub/sub messaging, and real-time data handling
A well-thought-out structure matters when building databases rooted in SQL. Optimization emerges naturally from intentional planning, not just added later. Design choices shape performance more than raw power ever could
- Focus on data consistency and performance tuning

---

Managing Servers and Infrastructure

Windows server management
Reverse Proxy with Nginx and Cloudflare
- Docker and container-based deployments
- Basic CI/CD pipelines for testing and deployment
- Production monitoring, logging, and debugging
- System-level performance optimization

---

Engineering Mindset

Starting with clarity means skipping shortcuts that clutter code. Growing a system matters more than rushing it live. From day one, keeping things maintainable shapes how tools get built. Simplicity wins when control beats cleverness, particularly over time.

---

Fling

Fling operates using a tailored system meant for speed, supporting instant chats and group interactions. Because needs shift over time, its structure adjusts without disrupting live conversations. Smooth messaging stays consistent even when demands evolve. Reliability remains central as conditions change around it.

Fling stands apart from Discord. Its purpose? Building a tool people can shape themselves - flexible, guided by users, built to last. Centered especially on Turkish communities, it aims to run steadily far into the future.

Fling Core Ideas

- WebSocket-based real-time messaging
- Modular and extensible backend architecture
- Microservice-ready system design
A system using Redis handles data movement while supporting quick access through temporary storage
- Security-first design using tokens, rate limiting, and permission systems

Fling begins modestly, yet expands gradually - introducing features, team members, tools - all without disrupting live operations. Progress continues step by step, shaping something durable instead of rushing toward temporary results.
